/*
 * vim:ts=4:sw=4:expandtab
 *
 * i3 - an improved dynamic tiling window manager
 * © 2009 Michael Stapelberg and contributors (see also: LICENSE)
 *
 * commands_parser.c: hand-written parser to parse commands (commands are what
 * you bind on keys and what you can send to i3 using the IPC interface, like
 * 'move left' or 'workspace 4').
 *
 * We use a hand-written parser instead of lex/yacc because our commands are
 * easy for humans, not for computers. Thus, it’s quite hard to specify a
 * context-free grammar for the commands. A PEG grammar would be easier, but
 * there’s downsides to every PEG parser generator I have come across so far.
 *
 * This parser is basically a state machine which looks for literals or strings
 * and can push either on a stack. After identifying a literal or string, it
 * will either transition to the current state, to a different state, or call a
 * function (like cmd_move()).
 *
 * Special care has been taken that error messages are useful and the code is
 * well testable (when compiled with -DTEST_PARSER it will output to stdout
 * instead of actually calling any function).
 *
 */

/*******************************************************************************
 * The data structures used for parsing. Essentially the current state and a
 * list of tokens for that state.
 *
 * The GENERATED_* files are generated by generate-commands-parser.pl with the
 * input parser-specs/commands.spec.
 ******************************************************************************/

#include <string>
#include "commands_parser.h"


CommandResult parse_command_old(const std::string &input, nlohmann::json *gen, ipc_client *client);
CommandResult parse_command_new(const std::string &input, nlohmann::json *gen, ipc_client *client);

/*
 * Parses a string (or word, if as_word is true). Extracted out of
 * parse_command so that it can be used in src/workspace.c for interpreting
 * workspace commands.
 *
 */
char *parse_string(const char **walk, bool as_word) {
    const char *beginning = *walk;
    /* Handle quoted strings (or words). */
    if (**walk == '"') {
        beginning++;
        (*walk)++;
        for (; **walk != '\0' && **walk != '"'; (*walk)++)
            if (**walk == '\\' && *(*walk + 1) != '\0')
                (*walk)++;
    } else {
        if (!as_word) {
            /* For a string (starting with 's'), the delimiters are
             * comma (,) and semicolon (;) which introduce a new
             * operation or command, respectively. Also, newlines
             * end a command. */
            while (**walk != ';' && **walk != ',' &&
                   **walk != '\0' && **walk != '\r' &&
                   **walk != '\n')
                (*walk)++;
        } else {
            /* For a word, the delimiters are white space (' ' or
             * '\t'), closing square bracket (]), comma (,) and
             * semicolon (;). */
            while (**walk != ' ' && **walk != '\t' &&
                   **walk != ']' && **walk != ',' &&
                   **walk != ';' && **walk != '\r' &&
                   **walk != '\n' && **walk != '\0')
                (*walk)++;
        }
    }
    if (*walk == beginning)
        return nullptr;

    char *str = (char*)scalloc(*walk - beginning + 1, 1);
    /* We copy manually to handle escaping of characters. */
    int inpos, outpos;
    for (inpos = 0, outpos = 0;
         inpos < (*walk - beginning);
         inpos++, outpos++) {
        /* We only handle escaped double quotes and backslashes to not break
         * backwards compatibility with people using \w in regular expressions
         * etc. */
        if (beginning[inpos] == '\\' && (beginning[inpos + 1] == '"' || beginning[inpos + 1] == '\\'))
            inpos++;
        str[outpos] = beginning[inpos];
    }

    return str;
}

/*
 * Parses and executes the given command. If a caller-allocated yajl_gen is
 * passed, a json reply will be generated in the format specified by the ipc
 * protocol. Pass NULL if no json reply is required.
 *
 * Free the returned CommandResult with command_result_free().
 */
CommandResult parse_command(const std::string &input, nlohmann::json *gen, ipc_client *client) {
    return parse_command_old(input, gen, client);
}
