/*
 * vim:ts=4:sw=4:expandtab
 *
 * i3 - an improved dynamic tiling window manager
 * © 2009 Michael Stapelberg and contributors (see also: LICENSE)
 *
 * startup.c: Startup notification code. Ensures a startup notification context
 *            is setup when launching applications. We store the current
 *            workspace to open windows in that startup notification context on
 *            the appropriate workspace.
 *
 */
module;
#define SN_API_NOT_YET_FROZEN 1
#include <libsn/sn-monitor.h>
#undef SN_API_NOT_YET_FROZEN
export module i3:startup;

import std;

class i3Window;
class X;

export {
    
    class ApplicationLauncher {
      public:
        /* Display handle for libstartup-notification */
        SnDisplay *sndisplay;
        
        explicit ApplicationLauncher(X &x);
        
        /**
         * Starts the given application by passing it through a shell. We use double
         * fork to avoid zombie processes. As the started application’s parent exits
         * (immediately), the application is reparented to init (process-id 1), which
         * correctly handles children, so we don’t have to do it :-).
         *
         * The shell used to start applications is the system's bourne shell (i.e.,
         * /bin/sh).
         *
         * The no_startup_id flag determines whether a startup notification context
         * (and ID) should be created, which is the default and encouraged behavior.
         *
         */
        void start_application(std::string_view command, bool no_startup_id);
        
        /**
         * Called by libstartup-notification when something happens
         *
         */
        void startup_monitor_event(SnMonitorEvent * event);

        /**
         * Renames workspaces that are mentioned in the startup sequences.
         *
         */
        void startup_sequence_rename_workspace(const char *old_name, const char *new_name);

        /**
         * Checks if the given window belongs to a startup notification by checking if
         * the _NET_STARTUP_ID property is set on the window (or on its leader, if it’s
         * unset).
         *
         * If so, returns the workspace on which the startup was initiated.
         * Returns NULL otherwise.
         *
         */
        std::optional<std::string> startup_workspace_for_window(i3Window * cwindow, xcb_get_property_reply_t * startup_id_reply);

        /**
         * Deletes the startup sequence for a window if it exists.
         *
         */
        void startup_sequence_delete_by_window(i3Window * win);
        
    };

    /**
     * Stores internal information about a startup sequence, like the workspace it
     * was initiated on.
     *
     */
    class Startup_Sequence {
    private:
        class ev_timer *timeout;

    public:
        /** startup ID for this sequence, generated by libstartup-notification */
        std::string id{};
        /** workspace on which this startup was initiated */
        std::string workspace{};
        /** libstartup-notification context for this launch */
        struct SnLauncherContext *context{};
        /** time at which this sequence should be deleted (after it was marked as
         * completed) */
        std::optional<std::chrono::time_point<std::chrono::system_clock>> delete_at{};

        void stop_timer();
        
        Startup_Sequence() = delete;
        Startup_Sequence(int screen, class WorkspaceCon *ws, std::string name, std::string description, std::string launchee, xcb_timestamp_t last_timestamp);
        
        Startup_Sequence(Startup_Sequence const &) = delete;
        Startup_Sequence& operator=(Startup_Sequence const &) = delete;

        virtual ~Startup_Sequence();
    };
}